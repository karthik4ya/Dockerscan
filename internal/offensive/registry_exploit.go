package offensive

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type RegistryCatalog struct {
	Repositories []string `json:"repositories"`
}

type TagList struct {
	Name string   `json:"name"`
	Tags []string `json:"tags"`
}

// ExploitRegistry performs a full suite of checks against a target registry URL
func ExploitRegistry(registryURL string) {
	fmt.Printf("[*] Auditing Registry: %s\n", registryURL)

	// 1. Check for Anonymous Access
	repos, err := checkAnonymousAccess(registryURL)
	if err != nil {
		fmt.Printf("[-] Access Denied or Error: %v\n", err)
		return
	}

	fmt.Printf("[!] VULNERABILITY: Anonymous Catalog Access Found! (%d repos)\n", len(repos))

	// If the catalog returned zero repositories, there's nothing further
	// to enumerate or test for write access. Avoid indexing repos[0].
	if len(repos) == 0 {
		fmt.Println("   Note: catalog is accessible but contains no repositories.")
		return
	}

	// 2. Enumerate Tags for each repository
	for _, repo := range repos {
		tags, _ := getTags(registryURL, repo)
		fmt.Printf("  > repo: %s | tags: %v\n", repo, tags)
	}

	// 3. Test for Write Permissions (The "Gold Mine")
	if testWriteAccess(registryURL, repos[0]) {
		fmt.Println("[!!!] CRITICAL: Anonymous PUSH (Write) Access detected! You can poison images.")
	}
}

func checkAnonymousAccess(url string) ([]string, error) {
	resp, err := http.Get(url + "/v2/_catalog")
	if err != nil || resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("auth required")
	}
	defer resp.Body.Close()

	var cat RegistryCatalog
	json.NewDecoder(resp.Body).Decode(&cat)
	return cat.Repositories, nil
}

func getTags(url, repo string) ([]string, error) {
	resp, _ := http.Get(fmt.Sprintf("%s/v2/%s/tags/list", url, repo))
	defer resp.Body.Close()

	var t TagList
	json.NewDecoder(resp.Body).Decode(&t)
	return t.Tags, nil
}

// testWriteAccess attempts to initiate a blob upload session without actually uploading a large file.
func testWriteAccess(url, repo string) bool {
	// API spec: POST /v2/<name>/blobs/uploads/
	target := fmt.Sprintf("%s/v2/%s/blobs/uploads/", url, repo)
	resp, err := http.Post(target, "application/json", nil)
	if err != nil {
		return false
	}
	defer resp.Body.Close()

	// If we get a 202 Accepted, it means the registry is ready to receive data from us
	return resp.StatusCode == http.StatusAccepted
}
